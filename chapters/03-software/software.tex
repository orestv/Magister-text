\chapter{Реалізація алгоритмів}                
        \section {програмне забезпечення}
            Для перевірки ефективності вищеописаних алгоритмів була створена їх програмна реалізація. У виборі мови програмування я керувався міркуваннями швидкодії та можливості контролю ресурсів комп'ютера. Вибір зупинився на С++. Реалізація являє собою консольну програму без графічного інтерфейсу, що зчитує дані з файла та зберігає результати кластеризації також у файлі.
            
    %        \begin{figure}
    %            \centering
    %            \includegraphics[scale=0.5]{chapters/02-work/Magister.pdf}
    %            \caption{Компонентна діаграма розробленого програмного забезпечення.}\label{fig:modules}
    %        \end{figure}
            
            Створено об'єктно-орієнтовану модель для зберігання об'єктів вибірки. Для зберігання власне даних використовуються стандартні колекції STL. Де-юре STL не належить до стандарту мови С++, але де-факто усі сучасні поширені компілятори мають підтримку цеї бібліотеки. Перша версія програми включала об'єкт ,,DataContainer'', який містив асоціативний контейнер std::map, що дозволяв звертатись до обєктів вибірки по ідентифікатору. Кожен елемент вибірки був об'єктом типу Object, що містив std::vector вказівників на об'єкти класу Attribute. Кожен Attribute містив числове значення відповідного атрибута та інформацію при присутність даного атрибута у відповідного об'єкта вибірки.
            
            Реалізовано також абстрактний клас AbstractMetric, який відповідав метриці простору. Архітектура програми дозволяє реалізувати довільну метрику простору. Таким чином при реалізації власне алгоритму кластеризації стало можливим абстрагуватись від типу метрики за допомогою механізму поліморфізму, доступного у С++. На даний момент із метрик реалізовано найпопулярнішу евклідову метрику.
            
            Після перших пробних запусків та профілювання виявлено, що найбільше часу витрачається на виконання функції обчислення відстані між об'єктами. Аналіз даних профілювання показав, що велика частка обчислювальних ресурсів витрачається доступ до атрибутів об'єкта. Це призвело до вимушеного спрощення існуючої структури, видалення із неї класу Attribute, і заміни його простим масивом чисел, що відповідають атрибутам. Інша суттєва оптимізація звелась до відмови від використання чисел із плаваючою комою точності (double) та переходу на числа одинарної точності (float). Швидкодія сучасних процесорів при роботі із останніми значно вища.
            
            Наступний етап очевидної оптимізації полягав у відмові від адресації об'єктів по ідентифікатору та переході від асоціативного контейнера до звичайного. Виявилось, що адресація за ідентифікатором не використовується взагалі, проте на неї витрачається багато ресурсів. Перехід до адресації за порядковим номером об'єкта в контейнері std::vector, що відтепер містив вказівники на об'єкти, дозволив зекономити значну кількість обчислювальних ресурсів.
            
            Подальші оптимізації в більшості стосувались розпаралелення виконання однотипних завдань. Наприклад, задача пошуку сусідів точки в її $\epsilon$-околі дозволяє розбити процес пошуку на декілька взаємонезалежних потоків, кожен з яких обробляв би певну частину вибірки, і по завершенню їх усіх просто об'єднати отримані дані. Оскільки програма виконувалась на двоядерному процесорі, це дозволило наростити продуктивність.
            
            Написання програми відбувалось у текстовому редакторі vim. Для компіляції програми обрано компілятор gcc. Відлагодження програми відбувалось за допомогою набору інструментів gdb. Відслідковування витрат пам'яті та профілювання програми здійснювалось за допомогою valgrind. При розробці використовувалась система контролю версій git.            
            
    \section {Тестові дані}
            Ефективність алгоритмів перевірялась на даних Data Mining Cup 2008 року. Це інформація про один із турів німецької державної лотереї. Кожен об'єкт вибірки відображає учасника лотереї. Був проведений збір інформації про учасників лотереї --- зокрема, сімейне та фінансове становище, освіта, рід діяльності та ін. Кількість об'єктів у вибірці --- 113477. Кожен об'єкт вибірки має унікальний числовий ідентифікатор.
            
            Для деяких об'єктів вибірки бракує даних. Для заповнення порожніх клітинок бази було застосовано модифікацію алгоритму ZET, описаного в \cite{Zagorujko}. В оригіналі цей алгоритм здійснює заповнення порожніх клітинок, користуючись інформацією про об'єкти, схожі на той, що містить порожню клітинку. Спочатку вибираються такі рядки, тоді серед цих рядків вибираються стовпці із найвищим коефіцієнтом лінійної регресії відносно атрибута, який потрібно передбачити. В кінці ітерації розв'язується рівняння лінійної регресії, коренем якого є шукане значення атрибута.
            
            Я використав спрощену версію алгоритму, що вибирає значення атрибута як середнє значення у стовпці серед об'єктів, близьких до даного.
            
            Для перевірки алгоритмів також використовувались синтетичні набори даних. Я генерував їх за допомогою утиліти, написаної спеціально із цею метою. Утиліта зчитує із вказаного файла послідовно інформацію про точку, яка буде центром групи об'єктів, та дозволені відхилення від центру по кожній координаті, і генерує вказану кількість об'єктів, розташованих випадковим чином у вказаних межах навколо центра. Задавши достатню кількість центральних точок та підібравши вдалі відхилення, можна добитись набору даних довільної форми. Зокрема, задавши центр угруповання приблизно посередині між усіма іншими точками, і досить великі відхилення по усіх координатах, можна досягнути ефекту шуму в даних. Як і основна програма, утиліта написана на С++.
